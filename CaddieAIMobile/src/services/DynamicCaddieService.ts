import { voiceAIApiService, CaddieResponseRequest } from './voiceAIApi';
import { textToSpeechService } from './TextToSpeechService';
import { realtimeAudioService } from './RealtimeAudioService';
import { CaddieContext, CaddieScenario, DynamicCaddieHelper } from './TextToSpeechService';

/**
 * Dynamic AI-powered caddie service that replaces hardcoded responses
 * with contextual, personalized golf advice generated by OpenAI GPT-4o mini
 * Now supports both realtime audio and text-to-speech fallback
 */
export class DynamicCaddieService implements DynamicCaddieHelper {
  private useRealtimeAudio: boolean = true; // Prefer realtime audio when available
  
  /**
   * Generate and speak dynamic caddie response for specific golf scenarios
   */
  async generateResponse(
    scenario: CaddieScenario,
    context: CaddieContext,
    userId: number,
    roundId: number,
    userInput?: string,
    priority: number = 5
  ): Promise<void> {
    try {
      console.log(`üéØ DynamicCaddieService: Generating response for scenario: ${scenario}`);

      // Try realtime audio first if enabled and connected
      const isRealtimeActive = realtimeAudioService.isConnectionActive();
      console.log('üîç DynamicCaddieService: Realtime audio status:', { useRealtimeAudio: this.useRealtimeAudio, isConnectionActive: isRealtimeActive });
      
      if (this.useRealtimeAudio && isRealtimeActive) {
        console.log('üéôÔ∏è DynamicCaddieService: Using realtime audio for response');
        await this.generateRealtimeResponse(scenario, context, userId, roundId, userInput);
        return;
      }

      // Fallback to traditional API + TTS approach
      console.log('üì¢ DynamicCaddieService: Using API + TTS fallback');
      await this.generateAPIResponse(scenario, context, userId, roundId, userInput, priority);

    } catch (error: any) {
      console.error(`‚ùå DynamicCaddieService: Error generating response for ${scenario}:`, error);
      
      // Final fallback to static response
      const fallbackMessage = this.getFallbackMessage(scenario, context);
      await textToSpeechService.speak(fallbackMessage, priority);
      
      console.warn(`üîÑ DynamicCaddieService: Used static fallback for ${scenario}: "${fallbackMessage}"`);
    }
  }

  /**
   * Generate response with enhanced context building
   */
  async generateResponseWithEnhancedContext(
    scenario: CaddieScenario,
    baseContext: Partial<CaddieContext>,
    userId: number,
    roundId: number,
    enhancementOptions?: {
      includeWeather?: boolean;
      includePlayerStats?: boolean;
      includeConversationHistory?: boolean;
      playerSkillLevel?: 'beginner' | 'intermediate' | 'advanced' | 'professional';
      communicationStyle?: 'encouraging' | 'technical' | 'balanced' | 'casual' | 'professional';
    },
    userInput?: string,
    priority: number = 5
  ): Promise<void> {
    try {
      // Enhance context with additional information
      const enhancedContext: CaddieContext = {
        ...baseContext,
        player: {
          ...baseContext.player,
          skillLevel: enhancementOptions?.playerSkillLevel ?? baseContext.player?.skillLevel ?? 'intermediate',
          communicationStyle: enhancementOptions?.communicationStyle ?? baseContext.player?.communicationStyle ?? 'encouraging',
        },
        metadata: {
          ...baseContext.metadata,
          enhancementOptions,
          requestTimestamp: new Date().toISOString(),
        }
      };

      // Generate response with enhanced context
      await this.generateResponse(scenario, enhancedContext, userId, roundId, userInput, priority);

    } catch (error) {
      console.error('Error generating enhanced caddie response:', error);
      
      // Fall back to basic response generation
      await this.generateResponse(scenario, baseContext, userId, roundId, userInput, priority);
    }
  }

  /**
   * Generate response for shot placement scenarios with automatic context building
   */
  async generateShotPlacementResponse(
    scenario: Extract<CaddieScenario, 'ShotPlacementWelcome' | 'ShotPlacementConfirmation' | 'ShotTrackingActivation'>,
    userId: number,
    roundId: number,
    shotContext: {
      currentHole?: number;
      targetDistanceYards?: number;
      recommendedClub?: string;
      currentLocation?: {
        latitude: number;
        longitude: number;
        accuracy?: number;
      };
      shotHistory?: Array<{
        shotNumber: number;
        club?: string;
        distanceYards: number;
        accuracy?: string;
        timestamp: number;
      }>;
    },
    priority: number = 8
  ): Promise<void> {
    const context: CaddieContext = {
      location: shotContext.currentLocation ? {
        currentHole: shotContext.currentHole,
        latitude: shotContext.currentLocation.latitude,
        longitude: shotContext.currentLocation.longitude,
        accuracyMeters: shotContext.currentLocation.accuracy ?? 10,
        withinCourseBoundaries: true,
        timestamp: new Date().toISOString(),
      } : undefined,
      golfContext: {
        currentHole: shotContext.currentHole,
        targetDistanceYards: shotContext.targetDistanceYards,
        recommendedClub: shotContext.recommendedClub,
        shotType: this.determineShotType(shotContext.targetDistanceYards ?? 150),
        shotPlacementActive: true,
        shotHistory: shotContext.shotHistory,
      },
      player: {
        skillLevel: 'intermediate', // Could be enhanced with user preferences
        communicationStyle: 'encouraging',
      }
    };

    await this.generateResponse(scenario, context, userId, roundId, undefined, priority);
  }

  /**
   * Generate club recommendation with enhanced distance and conditions context
   */
  async generateClubRecommendation(
    userId: number,
    roundId: number,
    distanceYards: number,
    conditions?: {
      windSpeedMph?: number;
      windDirection?: string;
      temperature?: number;
      courseCondition?: string;
    },
    currentHole?: number,
    playerClubDistances?: Record<string, number>,
    priority: number = 8
  ): Promise<void> {
    const context: CaddieContext = {
      golfContext: {
        currentHole,
        targetDistanceYards: distanceYards,
        shotType: this.determineShotType(distanceYards),
      },
      player: {
        skillLevel: 'intermediate',
        communicationStyle: 'encouraging',
        clubDistances: playerClubDistances,
      },
      conditions: conditions ? {
        windSpeedMph: conditions.windSpeedMph,
        windDirection: conditions.windDirection,
        temperatureFahrenheit: conditions.temperature,
        courseCondition: conditions.courseCondition,
        weatherDescription: this.buildWeatherDescription(conditions),
      } : undefined,
    };

    await this.generateResponse('ClubRecommendation', context, userId, roundId, undefined, priority);
  }

  /**
   * Generate realtime audio response using OpenAI Realtime API
   */
  private async generateRealtimeResponse(
    scenario: CaddieScenario,
    context: CaddieContext,
    userId: number,
    roundId: number,
    userInput?: string
  ): Promise<void> {
    try {
      console.log('üéôÔ∏è DynamicCaddieService: Generating realtime audio response');

      // Build contextual message for the AI caddie
      const contextualMessage = this.buildContextualMessage(scenario, context, userInput);
      
      // Send message to realtime audio service
      await realtimeAudioService.sendTextMessage(contextualMessage);
      
      console.log('‚úÖ DynamicCaddieService: Realtime audio response initiated');
    } catch (error) {
      console.error('‚ùå DynamicCaddieService: Error in realtime audio response:', error);
      throw error; // Will trigger fallback in parent method
    }
  }

  /**
   * Generate response using traditional API + TTS approach
   */
  private async generateAPIResponse(
    scenario: CaddieScenario,
    context: CaddieContext,
    userId: number,
    roundId: number,
    userInput?: string,
    priority: number = 5
  ): Promise<void> {
    try {
      console.log('üì° DynamicCaddieService: Generating API + TTS response');

      // Create request for voice AI API
      const requestData: CaddieResponseRequest = {
        userId,
        roundId,
        scenario,
        context,
        userInput,
        metadata: {
          customPrompt: this.buildScenarioPrompt(scenario, context),
        },
      };

      // Call voice AI API to generate response
      const response = await voiceAIApiService.generateCaddieResponse(requestData);
      
      // Speak the generated response using TTS
      await textToSpeechService.speak(response.message, priority);
      
      console.log(`‚úÖ DynamicCaddieService: API response generated and spoken: "${response.message}"`);
    } catch (error) {
      console.error('‚ùå DynamicCaddieService: Error in API + TTS response:', error);
      throw error; // Will trigger static fallback in parent method
    }
  }

  /**
   * Build contextual message for realtime audio AI
   */
  private buildContextualMessage(scenario: CaddieScenario, context: CaddieContext, userInput?: string): string {
    const parts: string[] = [];

    // Add scenario context
    switch (scenario) {
      case 'ShotPlacementWelcome':
        parts.push('Shot placement feature activated.');
        break;
      case 'ClubRecommendation':
        parts.push(`Club recommendation needed for ${context.golfContext?.targetDistanceYards || 150} yards.`);
        break;
      case 'ShotPlacementConfirmation':
        parts.push(`Shot target confirmed at ${context.golfContext?.targetDistanceYards || 150} yards.`);
        break;
      case 'ShotTrackingActivation':
        parts.push('Shot tracking activated.');
        break;
      case 'ShotInProgress':
        parts.push('Shot in progress.');
        break;
      case 'ShotCompletion':
        parts.push('Shot completed.');
        break;
      case 'MovementDetected':
        parts.push('Movement detected - shot tracking complete.');
        break;
      case 'DistanceAnnouncement':
        parts.push(`Distance announcement: ${context.golfContext?.targetDistanceYards || 150} yards.`);
        break;
      case 'ErrorHandling':
        parts.push('Handling error situation.');
        break;
    }

    // Add golf context if available
    if (context.golfContext?.currentHole) {
      parts.push(`Currently on hole ${context.golfContext.currentHole}.`);
    }

    if (context.golfContext?.recommendedClub) {
      parts.push(`Recommended club: ${context.golfContext.recommendedClub}.`);
    }

    // Add conditions if available
    if (context.conditions?.weatherDescription) {
      parts.push(`Conditions: ${context.conditions.weatherDescription}.`);
    }

    // Add user input if provided
    if (userInput) {
      parts.push(`User said: "${userInput}"`);
    }

    return parts.join(' ');
  }

  /**
   * Build scenario-specific prompt for API requests
   */
  private buildScenarioPrompt(scenario: CaddieScenario, context: CaddieContext): string {
    const basePrompt = "You are an expert golf caddie. Respond in 1-3 sentences with encouraging, professional advice.";
    
    switch (scenario) {
      case 'ClubRecommendation':
        return `${basePrompt} Recommend a club for ${context.golfContext?.targetDistanceYards || 150} yards considering the player's skill level and current conditions.`;
      
      case 'ShotPlacementWelcome':
        return `${basePrompt} Welcome the player to shot placement mode and briefly explain how to set their target.`;
      
      case 'ShotPlacementConfirmation':
        return `${basePrompt} Confirm the shot target placement and encourage the player for their upcoming shot.`;
      
      case 'ShotTrackingActivation':
        return `${basePrompt} Acknowledge shot tracking is active and provide encouraging pre-shot advice.`;
      
      default:
        return `${basePrompt} Provide helpful golf advice for the current situation.`;
    }
  }

  /**
   * Get fallback message for scenarios when API is unavailable
   */
  private getFallbackMessage(scenario: CaddieScenario, context: CaddieContext): string {
    switch (scenario) {
      case 'ShotPlacementWelcome':
        return "Welcome to shot placement! Tap the map to set your target, and I'll help with club selection.";
      
      case 'ClubRecommendation':
        const distance = context.golfContext?.targetDistanceYards ?? 150;
        return this.getStaticClubRecommendation(distance);
      
      case 'ShotPlacementConfirmation':
        const yards = context.golfContext?.targetDistanceYards ?? 150;
        return `Target set at ${yards} yards. When you're ready, activate shot tracking.`;
      
      case 'ShotTrackingActivation':
        return "Shot tracking active. Take your time and trust your swing.";
      
      case 'ShotInProgress':
        return "Looking good! Stay focused and finish strong.";
      
      case 'ShotCompletion':
        return "Nice shot! Ready for your next target.";
      
      case 'MovementDetected':
        return "Shot tracking complete. Great effort out there!";
      
      case 'DistanceAnnouncement':
        const announceYards = context.golfContext?.targetDistanceYards ?? 150;
        return `Distance to target: ${announceYards} yards.`;
      
      case 'ErrorHandling':
        return "No worries! Let's get back to your game. I'm here to help.";
      
      default:
        return "I'm here to help with your golf game! What do you need?";
    }
  }

  private getStaticClubRecommendation(yards: number): string {
    if (yards < 80) return "Try a wedge for this short approach.";
    if (yards < 120) return "A 9 or 8 iron should work well here.";
    if (yards < 150) return "Consider a 7 or 6 iron for this distance.";
    if (yards < 170) return "A 5 iron or hybrid might be perfect.";
    if (yards < 200) return "Try a 4 iron or fairway wood.";
    return "For this longer shot, consider a driver or 3 wood.";
  }

  private determineShotType(distanceYards: number): string {
    if (distanceYards < 50) return 'short-game';
    if (distanceYards < 100) return 'wedge-shot';
    if (distanceYards < 150) return 'approach-shot';
    if (distanceYards < 200) return 'mid-iron';
    if (distanceYards < 250) return 'long-iron';
    return 'driver-shot';
  }

  private buildWeatherDescription(conditions: {
    windSpeedMph?: number;
    windDirection?: string;
    temperature?: number;
    courseCondition?: string;
  }): string {
    const parts: string[] = [];
    
    if (conditions.temperature) {
      parts.push(`${conditions.temperature}¬∞F`);
    }
    
    if (conditions.windSpeedMph && conditions.windDirection) {
      parts.push(`${conditions.windSpeedMph}mph ${conditions.windDirection} wind`);
    }
    
    if (conditions.courseCondition) {
      parts.push(conditions.courseCondition);
    }
    
    return parts.join(', ') || 'Good conditions';
  }
}

// Export singleton instance
export const dynamicCaddieService = new DynamicCaddieService();

// Export factory function for dependency injection
export const getDynamicCaddieService = (): DynamicCaddieService => {
  return dynamicCaddieService;
};

// Helper function to check if service is available
export const isDynamicCaddieServiceAvailable = (): boolean => {
  try {
    return getDynamicCaddieService() != null;
  } catch (error) {
    console.error('Dynamic Caddie service is not available:', error);
    return false;
  }
};

// Export the service as default
export default dynamicCaddieService;