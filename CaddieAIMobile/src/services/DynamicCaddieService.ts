import { RealtimeAudioService } from './RealtimeAudioService';
import { OPENAI_CONFIG } from '../config/openai';
import { CaddieContext, CaddieScenario, DynamicCaddieHelper } from './TextToSpeechService';
import TokenStorage from './tokenStorage';

/**
 * Request queue item for managing sequential API calls
 */
interface QueuedRequest {
  id: string;
  scenario: CaddieScenario;
  context: CaddieContext;
  userId: number;
  roundId: number;
  userInput?: string;
  priority: number;
  timestamp: number;
}

/**
 * Dynamic AI-powered caddie service that replaces hardcoded responses
 * with contextual, personalized golf advice generated by OpenAI real-time audio API
 * Provides immediate, contextual voice responses for shot placement scenarios
 */
export class DynamicCaddieService implements DynamicCaddieHelper {
  private realtimeAudioService: RealtimeAudioService | null = null;
  private isConnected: boolean = false;
  private currentRoundId: number | null = null;
  
  // Request queuing system to prevent simultaneous API calls
  private requestQueue: QueuedRequest[] = [];
  private isProcessingQueue: boolean = false;
  private activeResponseId: string | null = null;
  
  /**
   * Initialize connection to OpenAI real-time audio service
   */
  private async initializeRealtimeAudio(roundId: number): Promise<void> {
    if (this.realtimeAudioService && this.isConnected && this.currentRoundId === roundId) {
      return; // Already connected to the same round
    }

    try {
      console.log('üéØ DynamicCaddieService: Initializing OpenAI real-time audio connection');
      
      // Create new realtime audio service with enhanced golf caddie instructions
      const golfInstructions = `You are an expert golf caddie assistant providing real-time advice during golf rounds. 
      Your role is to offer encouraging, professional guidance for shot placement, club selection, and course strategy.
      Keep responses brief (1-3 sentences), conversational, and supportive. 
      Use the 'ash' voice model for natural, warm communication.
      Focus on confidence-building and practical golf advice based on the current context.`;

      this.realtimeAudioService = new RealtimeAudioService({
        model: OPENAI_CONFIG.model,
        voice: OPENAI_CONFIG.voice,
        instructions: golfInstructions,
        temperature: OPENAI_CONFIG.temperature,
        enableVAD: true,
        vadThreshold: 0.5
      });

      // Get auth token and connect
      const authToken = await TokenStorage.getAccessToken();
      if (!authToken) {
        throw new Error('No authentication token available');
      }

      await this.realtimeAudioService.connect(roundId, authToken);
      this.isConnected = true;
      this.currentRoundId = roundId;
      
      // Set up response completion listener for queue management
      this.realtimeAudioService.on('responseCompleted', (response: any) => {
        console.log('üèÅ DynamicCaddieService: Response completed, processing next in queue');
        this.activeResponseId = null;
        this.isProcessingQueue = false;
        // Use setTimeout to ensure proper async execution
        setTimeout(() => this.processNextQueueItem(), 100);
      });
      
      console.log('‚úÖ DynamicCaddieService: Connected to OpenAI real-time audio');
    } catch (error) {
      console.error('‚ùå DynamicCaddieService: Failed to initialize real-time audio:', error);
      throw error;
    }
  }

  /**
   * Generate and speak dynamic caddie response for specific golf scenarios
   * Now uses request queuing to prevent simultaneous API calls
   */
  async generateResponse(
    scenario: CaddieScenario,
    context: CaddieContext,
    userId: number,
    roundId: number,
    userInput?: string,
    priority: number = 5
  ): Promise<void> {
    console.log(`üéØ DynamicCaddieService: Queuing response for scenario: ${scenario}`);

    // Add request to queue
    const queuedRequest: QueuedRequest = {
      id: `${scenario}-${Date.now()}-${Math.random().toString(36).substr(2, 9)}`,
      scenario,
      context,
      userId,
      roundId,
      userInput,
      priority,
      timestamp: Date.now()
    };

    this.addToQueue(queuedRequest);
    
    // Start processing queue if not already processing
    if (!this.isProcessingQueue) {
      this.processNextQueueItem();
    }
  }

  /**
   * Add request to queue, sorted by priority (higher priority first)
   */
  private addToQueue(request: QueuedRequest): void {
    this.requestQueue.push(request);
    
    // Sort by priority (higher priority first), then by timestamp (older first)
    this.requestQueue.sort((a, b) => {
      if (a.priority !== b.priority) {
        return b.priority - a.priority; // Higher priority first
      }
      return a.timestamp - b.timestamp; // Older requests first for same priority
    });

    console.log(`üìã DynamicCaddieService: Request queued. Queue length: ${this.requestQueue.length}`);
  }

  /**
   * Process next item in the queue
   */
  private async processNextQueueItem(): Promise<void> {
    console.log(`üîÑ DynamicCaddieService: Attempting to process next queue item. Processing: ${this.isProcessingQueue}, Queue length: ${this.requestQueue.length}, Active: ${!!this.activeResponseId}`);
    
    if (this.isProcessingQueue) {
      console.log('‚ö†Ô∏è DynamicCaddieService: Already processing queue, skipping');
      return;
    }
    
    if (this.requestQueue.length === 0) {
      console.log('üìã DynamicCaddieService: Queue is empty');
      return;
    }
    
    if (this.activeResponseId) {
      console.log('‚ö†Ô∏è DynamicCaddieService: Active response in progress, skipping');
      return;
    }

    this.isProcessingQueue = true;
    const request = this.requestQueue.shift();
    
    if (!request) {
      this.isProcessingQueue = false;
      console.log('‚ùå DynamicCaddieService: No request found after shifting queue');
      return;
    }

    try {
      console.log(`üîÑ DynamicCaddieService: Processing queued request: ${request.scenario} (ID: ${request.id})`);
      this.activeResponseId = request.id;
      
      await this.executeQueuedRequest(request);
      
    } catch (error: any) {
      console.error(`‚ùå DynamicCaddieService: Error processing queued request ${request.id}:`, error);
      
      // Clear active response and continue with next item
      this.activeResponseId = null;
      this.isProcessingQueue = false;
      
      // Process next item after short delay
      setTimeout(() => this.processNextQueueItem(), 500);
    }
  }

  /**
   * Execute a queued request
   */
  private async executeQueuedRequest(request: QueuedRequest): Promise<void> {
    try {
      console.log(`üéØ DynamicCaddieService: Executing response for scenario: ${request.scenario}`);

      // Initialize or ensure real-time audio connection
      await this.initializeRealtimeAudio(request.roundId);

      if (!this.realtimeAudioService || !this.isConnected) {
        throw new Error('Real-time audio service not available');
      }

      // Update contextual instructions for this scenario
      await this.updateContextualInstructions(request.scenario, request.context);

      // Build contextual message for the AI
      const contextualMessage = this.buildContextualMessage(request.scenario, request.context, request.userInput);
      
      console.log(`üé§ DynamicCaddieService: Sending context to OpenAI: "${contextualMessage}"`);
      
      // Send message to OpenAI real-time audio for immediate voice response
      await this.realtimeAudioService.sendTextMessage(contextualMessage);
      
      console.log('‚úÖ DynamicCaddieService: Message sent to OpenAI real-time audio');

      // Add timeout fallback in case response completion event isn't fired
      setTimeout(() => {
        if (this.activeResponseId === request.id && this.isProcessingQueue) {
          console.warn('‚ö†Ô∏è DynamicCaddieService: Response timeout, forcing queue continuation');
          this.activeResponseId = null;
          this.isProcessingQueue = false;
          this.processNextQueueItem();
        }
      }, 15000); // 15 second timeout

      // Note: Response completion will be handled by the responseCompleted listener
      // which will call processNextQueueItem() and reset isProcessingQueue

    } catch (error: any) {
      console.error(`‚ùå DynamicCaddieService: Error executing request for ${request.scenario}:`, error);
      
      // Fallback to static message if OpenAI fails
      const fallbackMessage = this.getFallbackMessage(request.scenario, request.context);
      console.warn(`üîÑ DynamicCaddieService: Using fallback message: "${fallbackMessage}"`);
      
      // Clear processing state and continue with queue
      this.activeResponseId = null;
      this.isProcessingQueue = false;
      setTimeout(() => this.processNextQueueItem(), 500);
    }
  }

  /**
   * Generate response with enhanced context building
   */
  async generateResponseWithEnhancedContext(
    scenario: CaddieScenario,
    baseContext: Partial<CaddieContext>,
    userId: number,
    roundId: number,
    enhancementOptions?: {
      includeWeather?: boolean;
      includePlayerStats?: boolean;
      includeConversationHistory?: boolean;
      playerSkillLevel?: 'beginner' | 'intermediate' | 'advanced' | 'professional';
      communicationStyle?: 'encouraging' | 'technical' | 'balanced' | 'casual' | 'professional';
    },
    userInput?: string,
    priority: number = 5
  ): Promise<void> {
    try {
      // Enhance context with additional information
      const enhancedContext: CaddieContext = {
        ...baseContext,
        player: {
          ...baseContext.player,
          skillLevel: enhancementOptions?.playerSkillLevel ?? baseContext.player?.skillLevel ?? 'intermediate',
          communicationStyle: enhancementOptions?.communicationStyle ?? baseContext.player?.communicationStyle ?? 'encouraging',
        },
        metadata: {
          ...baseContext.metadata,
          enhancementOptions,
          requestTimestamp: new Date().toISOString(),
        }
      };

      // Generate response with enhanced context
      await this.generateResponse(scenario, enhancedContext, userId, roundId, userInput, priority);

    } catch (error) {
      console.error('Error generating enhanced caddie response:', error);
      
      // Fall back to basic response generation
      await this.generateResponse(scenario, baseContext, userId, roundId, userInput, priority);
    }
  }

  /**
   * Generate response for shot placement scenarios with automatic context building
   */
  async generateShotPlacementResponse(
    scenario: Extract<CaddieScenario, 'ShotPlacementWelcome' | 'ShotPlacementConfirmation' | 'ShotTrackingActivation'>,
    userId: number,
    roundId: number,
    shotContext: {
      currentHole?: number;
      targetDistanceYards?: number;
      recommendedClub?: string;
      currentLocation?: {
        latitude: number;
        longitude: number;
        accuracy?: number;
      };
      shotHistory?: Array<{
        shotNumber: number;
        club?: string;
        distanceYards: number;
        accuracy?: string;
        timestamp: number;
      }>;
    },
    priority: number = 8
  ): Promise<void> {
    const context: CaddieContext = {
      location: shotContext.currentLocation ? {
        currentHole: shotContext.currentHole,
        latitude: shotContext.currentLocation.latitude,
        longitude: shotContext.currentLocation.longitude,
        accuracyMeters: shotContext.currentLocation.accuracy ?? 10,
        withinCourseBoundaries: true,
        timestamp: new Date().toISOString(),
      } : undefined,
      golfContext: {
        currentHole: shotContext.currentHole,
        targetDistanceYards: shotContext.targetDistanceYards,
        recommendedClub: shotContext.recommendedClub,
        shotType: this.determineShotType(shotContext.targetDistanceYards ?? 150),
        shotPlacementActive: true,
        shotHistory: shotContext.shotHistory,
      },
      player: {
        skillLevel: 'intermediate', // Could be enhanced with user preferences
        communicationStyle: 'encouraging',
      }
    };

    await this.generateResponse(scenario, context, userId, roundId, undefined, priority);
  }

  /**
   * Generate club recommendation with enhanced distance and conditions context
   */
  async generateClubRecommendation(
    userId: number,
    roundId: number,
    distanceYards: number,
    conditions?: {
      windSpeedMph?: number;
      windDirection?: string;
      temperature?: number;
      courseCondition?: string;
    },
    currentHole?: number,
    playerClubDistances?: Record<string, number>,
    priority: number = 8
  ): Promise<void> {
    const context: CaddieContext = {
      golfContext: {
        currentHole,
        targetDistanceYards: distanceYards,
        shotType: this.determineShotType(distanceYards),
      },
      player: {
        skillLevel: 'intermediate',
        communicationStyle: 'encouraging',
        clubDistances: playerClubDistances,
      },
      conditions: conditions ? {
        windSpeedMph: conditions.windSpeedMph,
        windDirection: conditions.windDirection,
        temperatureFahrenheit: conditions.temperature,
        courseCondition: conditions.courseCondition,
        weatherDescription: this.buildWeatherDescription(conditions),
      } : undefined,
    };

    await this.generateResponse('ClubRecommendation', context, userId, roundId, undefined, priority);
  }

  /**
   * Note: Realtime audio functionality moved to VoiceChatModalV2 component
   * This service now focuses on contextual API responses with TTS
   */

  /**
   * Cleanup and disconnect from real-time audio service
   */
  async cleanup(): Promise<void> {
    // Clear request queue and processing state
    this.requestQueue = [];
    this.isProcessingQueue = false;
    this.activeResponseId = null;
    
    if (this.realtimeAudioService && this.isConnected) {
      try {
        await this.realtimeAudioService.disconnect();
        console.log('üßπ DynamicCaddieService: Disconnected from real-time audio service');
      } catch (error) {
        console.error('‚ùå DynamicCaddieService: Error during cleanup:', error);
      }
    }
    
    this.realtimeAudioService = null;
    this.isConnected = false;
    this.currentRoundId = null;
  }

  /**
   * Build contextual message for realtime audio AI
   */
  private buildContextualMessage(scenario: CaddieScenario, context: CaddieContext, userInput?: string): string {
    const parts: string[] = [];

    // Add scenario context
    switch (scenario) {
      case 'ShotPlacementWelcome':
        parts.push('Shot placement feature activated.');
        break;
      case 'ClubRecommendation':
        parts.push(`Club recommendation needed for ${context.golfContext?.targetDistanceYards || 150} yards.`);
        break;
      case 'ShotPlacementConfirmation':
        parts.push(`Shot target confirmed at ${context.golfContext?.targetDistanceYards || 150} yards.`);
        break;
      case 'ShotTrackingActivation':
        parts.push('Shot tracking activated.');
        break;
      case 'ShotInProgress':
        parts.push('Shot in progress.');
        break;
      case 'ShotCompletion':
        parts.push('Shot completed.');
        break;
      case 'MovementDetected':
        parts.push('Movement detected - shot tracking complete.');
        break;
      case 'DistanceAnnouncement':
        parts.push(`Distance announcement: ${context.golfContext?.targetDistanceYards || 150} yards.`);
        break;
      case 'ErrorHandling':
        parts.push('Handling error situation.');
        break;
    }

    // Add golf context if available
    if (context.golfContext?.currentHole) {
      parts.push(`Currently on hole ${context.golfContext.currentHole}.`);
    }

    if (context.golfContext?.recommendedClub) {
      parts.push(`Recommended club: ${context.golfContext.recommendedClub}.`);
    }

    // Add conditions if available
    if (context.conditions?.weatherDescription) {
      parts.push(`Conditions: ${context.conditions.weatherDescription}.`);
    }

    // Add user input if provided
    if (userInput) {
      parts.push(`User said: "${userInput}"`);
    }

    return parts.join(' ');
  }

  /**
   * Add contextual instruction to the real-time audio service for enhanced responses
   */
  private async updateContextualInstructions(scenario: CaddieScenario, context: CaddieContext): Promise<void> {
    if (!this.realtimeAudioService) return;

    // Build enhanced instructions based on scenario and context
    const baseInstruction = `You are an expert golf caddie providing real-time advice. Respond in 1-3 sentences with encouraging, supportive guidance.`;
    
    let scenarioInstruction = '';
    switch (scenario) {
      case 'ClubRecommendation':
        scenarioInstruction = `Focus on club selection for ${context.golfContext?.targetDistanceYards || 150} yards. Consider conditions and player skill level.`;
        break;
      case 'ShotPlacementWelcome':
        scenarioInstruction = `Welcome the player to shot placement mode. Briefly explain how to use it with confidence.`;
        break;
      case 'ShotPlacementConfirmation':
        scenarioInstruction = `Confirm the shot target and provide encouraging pre-shot advice.`;
        break;
      case 'ShotTrackingActivation':
        scenarioInstruction = `Acknowledge shot tracking is active. Provide brief, confidence-building advice.`;
        break;
      default:
        scenarioInstruction = `Provide helpful, encouraging golf advice for the current situation.`;
    }

    // Update the service configuration with enhanced context
    this.realtimeAudioService.updateConfig({
      instructions: `${baseInstruction} ${scenarioInstruction}`,
      voice: 'ash',
      temperature: 0.7
    });
  }

  /**
   * Get fallback message for scenarios when API is unavailable
   */
  private getFallbackMessage(scenario: CaddieScenario, context: CaddieContext): string {
    switch (scenario) {
      case 'ShotPlacementWelcome':
        return "Welcome to shot placement! Tap the map to set your target, and I'll help with club selection.";
      
      case 'ClubRecommendation':
        const distance = context.golfContext?.targetDistanceYards ?? 150;
        return this.getStaticClubRecommendation(distance);
      
      case 'ShotPlacementConfirmation':
        const yards = context.golfContext?.targetDistanceYards ?? 150;
        return `Target set at ${yards} yards. When you're ready, activate shot tracking.`;
      
      case 'ShotTrackingActivation':
        return "Shot tracking active. Take your time and trust your swing.";
      
      case 'ShotInProgress':
        return "Looking good! Stay focused and finish strong.";
      
      case 'ShotCompletion':
        return "Nice shot! Ready for your next target.";
      
      case 'MovementDetected':
        return "Shot tracking complete. Great effort out there!";
      
      case 'DistanceAnnouncement':
        const announceYards = context.golfContext?.targetDistanceYards ?? 150;
        return `Distance to target: ${announceYards} yards.`;
      
      case 'ErrorHandling':
        return "No worries! Let's get back to your game. I'm here to help.";
      
      default:
        return "I'm here to help with your golf game! What do you need?";
    }
  }

  private getStaticClubRecommendation(yards: number): string {
    if (yards < 80) return "Try a wedge for this short approach.";
    if (yards < 120) return "A 9 or 8 iron should work well here.";
    if (yards < 150) return "Consider a 7 or 6 iron for this distance.";
    if (yards < 170) return "A 5 iron or hybrid might be perfect.";
    if (yards < 200) return "Try a 4 iron or fairway wood.";
    return "For this longer shot, consider a driver or 3 wood.";
  }

  private determineShotType(distanceYards: number): string {
    if (distanceYards < 50) return 'short-game';
    if (distanceYards < 100) return 'wedge-shot';
    if (distanceYards < 150) return 'approach-shot';
    if (distanceYards < 200) return 'mid-iron';
    if (distanceYards < 250) return 'long-iron';
    return 'driver-shot';
  }

  private buildWeatherDescription(conditions: {
    windSpeedMph?: number;
    windDirection?: string;
    temperature?: number;
    courseCondition?: string;
  }): string {
    const parts: string[] = [];
    
    if (conditions.temperature) {
      parts.push(`${conditions.temperature}¬∞F`);
    }
    
    if (conditions.windSpeedMph && conditions.windDirection) {
      parts.push(`${conditions.windSpeedMph}mph ${conditions.windDirection} wind`);
    }
    
    if (conditions.courseCondition) {
      parts.push(conditions.courseCondition);
    }
    
    return parts.join(', ') || 'Good conditions';
  }
}

// Export singleton instance
export const dynamicCaddieService = new DynamicCaddieService();

// Export factory function for dependency injection
export const getDynamicCaddieService = (): DynamicCaddieService => {
  return dynamicCaddieService;
};

// Helper function to check if service is available
export const isDynamicCaddieServiceAvailable = (): boolean => {
  try {
    return getDynamicCaddieService() != null;
  } catch (error) {
    console.error('Dynamic Caddie service is not available:', error);
    return false;
  }
};

// Export the service as default
export default dynamicCaddieService;