import { RealtimeAudioService } from './RealtimeAudioService';
import { OPENAI_CONFIG } from '../config/openai';
import { CaddieContext, CaddieScenario, DynamicCaddieHelper } from './TextToSpeechService';
import TokenStorage from './tokenStorage';

/**
 * Request queue item for managing sequential API calls
 */
interface QueuedRequest {
  id: string;
  scenario: CaddieScenario;
  context: CaddieContext;
  userId: number;
  roundId: number;
  userInput?: string;
  priority: number;
  timestamp: number;
}

/**
 * Dynamic AI-powered caddie service that replaces hardcoded responses
 * with contextual, personalized golf advice generated by OpenAI real-time audio API
 * Provides immediate, contextual voice responses for shot placement scenarios
 */
export class DynamicCaddieService implements DynamicCaddieHelper {
  private realtimeAudioService: RealtimeAudioService | null = null;
  private isConnected: boolean = false;
  private currentRoundId: number | null = null;
  
  // Request queuing system to prevent simultaneous API calls
  private requestQueue: QueuedRequest[] = [];
  private isProcessingQueue: boolean = false;
  private activeResponseId: string | null = null;
  
  // Response caching for cost efficiency
  private responseCache: Map<string, string> = new Map();
  private cacheTimeout = 300000; // 5 minutes
  
  /**
   * Initialize connection to OpenAI real-time audio service
   */
  private async initializeRealtimeAudio(roundId: number): Promise<void> {
    if (this.realtimeAudioService && this.isConnected && this.currentRoundId === roundId) {
      return; // Already connected to the same round
    }

    try {
      console.log('üéØ DynamicCaddieService: Initializing OpenAI real-time audio connection');
      
      // Concise golf caddie instructions for helpful, brief responses
      const golfInstructions = `Brief helpful golf caddie. Keep responses under 10 words.`;

      this.realtimeAudioService = new RealtimeAudioService({
        model: OPENAI_CONFIG.model,
        voice: OPENAI_CONFIG.voice,
        instructions: golfInstructions,
        temperature: OPENAI_CONFIG.temperature,
        enableVAD: true,
        vadThreshold: 0.5
      });

      // Get auth token and connect
      const authToken = await TokenStorage.getAccessToken();
      if (!authToken) {
        throw new Error('No authentication token available');
      }

      await this.realtimeAudioService.connect(roundId, authToken);
      this.isConnected = true;
      this.currentRoundId = roundId;
      
      // Set up response completion listener for queue management
      this.realtimeAudioService.on('responseCompleted', (response: any) => {
        console.log('üèÅ DynamicCaddieService: Response completed, processing next in queue');
        this.activeResponseId = null;
        this.isProcessingQueue = false;
        // Use setTimeout to ensure proper async execution
        setTimeout(() => this.processNextQueueItem(), 100);
      });
      
      console.log('‚úÖ DynamicCaddieService: Connected to OpenAI real-time audio');
    } catch (error) {
      console.error('‚ùå DynamicCaddieService: Failed to initialize real-time audio:', error);
      throw error;
    }
  }

  /**
   * Generate and speak dynamic caddie response for specific golf scenarios
   * Now uses request queuing and caching to prevent simultaneous API calls and reduce costs
   */
  async generateResponse(
    scenario: CaddieScenario,
    context: CaddieContext,
    userId: number,
    roundId: number,
    userInput?: string,
    priority: number = 5
  ): Promise<void> {
    console.log(`üéØ DynamicCaddieService: Queuing response for scenario: ${scenario}`);

    // Check cache first for cost efficiency
    const cacheKey = this.buildCacheKey(scenario, context);
    const cachedResponse = this.getCachedResponse(cacheKey);
    if (cachedResponse) {
      console.log(`üí∞ DynamicCaddieService: Using cached response for ${scenario}`);
      // For cached responses, use fallback text-to-speech instead of OpenAI
      const fallbackMessage = this.getFallbackMessage(scenario, context);
      // Could implement basic TTS here if available
      return;
    }

    // Add request to queue
    const queuedRequest: QueuedRequest = {
      id: `${scenario}-${Date.now()}-${Math.random().toString(36).substr(2, 9)}`,
      scenario,
      context,
      userId,
      roundId,
      userInput,
      priority,
      timestamp: Date.now()
    };

    this.addToQueue(queuedRequest);
    
    // Start processing queue if not already processing
    if (!this.isProcessingQueue) {
      this.processNextQueueItem();
    }
  }

  /**
   * Add request to queue, sorted by priority (higher priority first)
   */
  private addToQueue(request: QueuedRequest): void {
    this.requestQueue.push(request);
    
    // Sort by priority (higher priority first), then by timestamp (older first)
    this.requestQueue.sort((a, b) => {
      if (a.priority !== b.priority) {
        return b.priority - a.priority; // Higher priority first
      }
      return a.timestamp - b.timestamp; // Older requests first for same priority
    });

    console.log(`üìã DynamicCaddieService: Request queued. Queue length: ${this.requestQueue.length}`);
  }

  /**
   * Process next item in the queue
   */
  private async processNextQueueItem(): Promise<void> {
    console.log(`üîÑ DynamicCaddieService: Attempting to process next queue item. Processing: ${this.isProcessingQueue}, Queue length: ${this.requestQueue.length}, Active: ${!!this.activeResponseId}`);
    
    if (this.isProcessingQueue) {
      console.log('‚ö†Ô∏è DynamicCaddieService: Already processing queue, skipping');
      return;
    }
    
    if (this.requestQueue.length === 0) {
      console.log('üìã DynamicCaddieService: Queue is empty');
      return;
    }
    
    if (this.activeResponseId) {
      console.log('‚ö†Ô∏è DynamicCaddieService: Active response in progress, skipping');
      return;
    }

    this.isProcessingQueue = true;
    const request = this.requestQueue.shift();
    
    if (!request) {
      this.isProcessingQueue = false;
      console.log('‚ùå DynamicCaddieService: No request found after shifting queue');
      return;
    }

    try {
      console.log(`üîÑ DynamicCaddieService: Processing queued request: ${request.scenario} (ID: ${request.id})`);
      this.activeResponseId = request.id;
      
      await this.executeQueuedRequest(request);
      
    } catch (error: any) {
      console.error(`‚ùå DynamicCaddieService: Error processing queued request ${request.id}:`, error);
      
      // Clear active response and continue with next item
      this.activeResponseId = null;
      this.isProcessingQueue = false;
      
      // Process next item after short delay
      setTimeout(() => this.processNextQueueItem(), 500);
    }
  }

  /**
   * Execute a queued request
   */
  private async executeQueuedRequest(request: QueuedRequest): Promise<void> {
    try {
      console.log(`üéØ DynamicCaddieService: Executing response for scenario: ${request.scenario}`);

      // Initialize or ensure real-time audio connection
      await this.initializeRealtimeAudio(request.roundId);

      if (!this.realtimeAudioService || !this.isConnected) {
        throw new Error('Real-time audio service not available');
      }

      // Update contextual instructions for this scenario
      await this.updateContextualInstructions(request.scenario, request.context);

      // Build contextual message for the AI
      const contextualMessage = this.buildContextualMessage(request.scenario, request.context, request.userInput);
      
      console.log(`üé§ DynamicCaddieService: Sending context to OpenAI: "${contextualMessage}"`);
      
      // Send message to OpenAI real-time audio for immediate voice response
      await this.realtimeAudioService.sendTextMessage(contextualMessage);
      
      console.log('‚úÖ DynamicCaddieService: Message sent to OpenAI real-time audio');

      // Add timeout fallback in case response completion event isn't fired
      setTimeout(() => {
        if (this.activeResponseId === request.id && this.isProcessingQueue) {
          console.warn('‚ö†Ô∏è DynamicCaddieService: Response timeout, forcing queue continuation');
          this.activeResponseId = null;
          this.isProcessingQueue = false;
          this.processNextQueueItem();
        }
      }, 15000); // 15 second timeout

      // Note: Response completion will be handled by the responseCompleted listener
      // which will call processNextQueueItem() and reset isProcessingQueue

    } catch (error: any) {
      console.error(`‚ùå DynamicCaddieService: Error executing request for ${request.scenario}:`, error);
      
      // Fallback to static message if OpenAI fails
      const fallbackMessage = this.getFallbackMessage(request.scenario, request.context);
      console.warn(`üîÑ DynamicCaddieService: Using fallback message: "${fallbackMessage}"`);
      
      // Clear processing state and continue with queue
      this.activeResponseId = null;
      this.isProcessingQueue = false;
      setTimeout(() => this.processNextQueueItem(), 500);
    }
  }

  /**
   * Generate response with enhanced context building
   */
  async generateResponseWithEnhancedContext(
    scenario: CaddieScenario,
    baseContext: Partial<CaddieContext>,
    userId: number,
    roundId: number,
    enhancementOptions?: {
      includeWeather?: boolean;
      includePlayerStats?: boolean;
      includeConversationHistory?: boolean;
      playerSkillLevel?: 'beginner' | 'intermediate' | 'advanced' | 'professional';
      communicationStyle?: 'encouraging' | 'technical' | 'balanced' | 'casual' | 'professional';
    },
    userInput?: string,
    priority: number = 5
  ): Promise<void> {
    try {
      // Enhance context with additional information
      const enhancedContext: CaddieContext = {
        ...baseContext,
        player: {
          ...baseContext.player,
          skillLevel: enhancementOptions?.playerSkillLevel ?? baseContext.player?.skillLevel ?? 'intermediate',
          communicationStyle: enhancementOptions?.communicationStyle ?? baseContext.player?.communicationStyle ?? 'encouraging',
        },
        metadata: {
          ...baseContext.metadata,
          enhancementOptions,
          requestTimestamp: new Date().toISOString(),
        }
      };

      // Generate response with enhanced context
      await this.generateResponse(scenario, enhancedContext, userId, roundId, userInput, priority);

    } catch (error) {
      console.error('Error generating enhanced caddie response:', error);
      
      // Fall back to basic response generation
      await this.generateResponse(scenario, baseContext, userId, roundId, userInput, priority);
    }
  }

  /**
   * Generate response for shot placement scenarios with automatic context building
   */
  async generateShotPlacementResponse(
    scenario: Extract<CaddieScenario, 'ShotPlacementWelcome' | 'ShotPlacementConfirmation' | 'ShotTrackingActivation'>,
    userId: number,
    roundId: number,
    shotContext: {
      currentHole?: number;
      targetDistanceYards?: number;
      recommendedClub?: string;
      currentLocation?: {
        latitude: number;
        longitude: number;
        accuracy?: number;
      };
      shotHistory?: Array<{
        shotNumber: number;
        club?: string;
        distanceYards: number;
        accuracy?: string;
        timestamp: number;
      }>;
    },
    priority: number = 8
  ): Promise<void> {
    const context: CaddieContext = {
      location: shotContext.currentLocation ? {
        currentHole: shotContext.currentHole,
        latitude: shotContext.currentLocation.latitude,
        longitude: shotContext.currentLocation.longitude,
        accuracyMeters: shotContext.currentLocation.accuracy ?? 10,
        withinCourseBoundaries: true,
        timestamp: new Date().toISOString(),
      } : undefined,
      golfContext: {
        currentHole: shotContext.currentHole,
        targetDistanceYards: shotContext.targetDistanceYards,
        recommendedClub: shotContext.recommendedClub,
        shotType: this.determineShotType(shotContext.targetDistanceYards ?? 150),
        shotPlacementActive: true,
        shotHistory: shotContext.shotHistory,
      },
      player: {
        skillLevel: 'intermediate', // Could be enhanced with user preferences
        communicationStyle: 'encouraging',
      }
    };

    await this.generateResponse(scenario, context, userId, roundId, undefined, priority);
  }

  /**
   * Generate club recommendation with enhanced distance and conditions context
   */
  async generateClubRecommendation(
    userId: number,
    roundId: number,
    distanceYards: number,
    conditions?: {
      windSpeedMph?: number;
      windDirection?: string;
      temperature?: number;
      courseCondition?: string;
    },
    currentHole?: number,
    playerClubDistances?: Record<string, number>,
    priority: number = 8
  ): Promise<void> {
    const context: CaddieContext = {
      golfContext: {
        currentHole,
        targetDistanceYards: distanceYards,
        shotType: this.determineShotType(distanceYards),
      },
      player: {
        skillLevel: 'intermediate',
        communicationStyle: 'encouraging',
        clubDistances: playerClubDistances,
      },
      conditions: conditions ? {
        windSpeedMph: conditions.windSpeedMph,
        windDirection: conditions.windDirection,
        temperatureFahrenheit: conditions.temperature,
        courseCondition: conditions.courseCondition,
        weatherDescription: this.buildWeatherDescription(conditions),
      } : undefined,
    };

    await this.generateResponse('ClubRecommendation', context, userId, roundId, undefined, priority);
  }

  /**
   * Note: Realtime audio functionality moved to VoiceChatModalV2 component
   * This service now focuses on contextual API responses with TTS
   */

  /**
   * Cleanup and disconnect from real-time audio service
   */
  async cleanup(): Promise<void> {
    // Clear request queue and processing state
    this.requestQueue = [];
    this.isProcessingQueue = false;
    this.activeResponseId = null;
    
    if (this.realtimeAudioService && this.isConnected) {
      try {
        await this.realtimeAudioService.disconnect();
        console.log('üßπ DynamicCaddieService: Disconnected from real-time audio service');
      } catch (error) {
        console.error('‚ùå DynamicCaddieService: Error during cleanup:', error);
      }
    }
    
    this.realtimeAudioService = null;
    this.isConnected = false;
    this.currentRoundId = null;
  }

  /**
   * Build minimal contextual message for 2 core shot placement scenarios only
   */
  private buildContextualMessage(scenario: CaddieScenario, context: CaddieContext, userInput?: string): string {
    const distance = context.golfContext?.targetDistanceYards || 150;

    // Only handle the 2 essential shot placement cases
    switch (scenario) {
      case 'ShotPlacementWelcome':
        return 'Shot placement activated';
      case 'ClubRecommendation':
        return `${distance} yards club recommendation`;
      default:
        return 'Golf help';
    }
  }

  /**
   * Update contextual instructions for 2 core shot placement scenarios only
   */
  private async updateContextualInstructions(scenario: CaddieScenario, context: CaddieContext): Promise<void> {
    if (!this.realtimeAudioService) return;

    // Concise instructions for only 2 essential cases
    let instruction = 'Brief helpful golf caddie. Under 10 words.';
    switch (scenario) {
      case 'ShotPlacementWelcome':
        instruction = 'Welcome user to shot placement mode';
        break;
      case 'ClubRecommendation':
        instruction = 'Recommend club for distance';
        break;
      default:
        instruction = 'Brief helpful golf caddie. Under 10 words.';
    }

    // Update with concise scenario instructions
    this.realtimeAudioService.updateConfig({
      instructions: instruction,
      voice: 'ash',
      temperature: 0.6 // Minimum allowed for real-time API
    });
  }

  /**
   * Get fallback message for scenarios when API is unavailable
   */
  private getFallbackMessage(scenario: CaddieScenario, context: CaddieContext): string {
    switch (scenario) {
      case 'ShotPlacementWelcome':
        return "Please select your shot location";
      
      case 'ClubRecommendation':
        const distance = context.golfContext?.targetDistanceYards ?? 150;
        return this.getStaticClubRecommendation(distance);
      
      case 'ErrorHandling':
        return "No worries! Let's get back to your game.";
      
      default:
        return "I'm here to help with your golf game!";
    }
  }

  private getStaticClubRecommendation(yards: number): string {
    if (yards < 80) return `For ${yards} yards, try using a wedge`;
    if (yards < 120) return `For ${yards} yards, try using a 9 iron`;
    if (yards < 150) return `For ${yards} yards, try using a 7 iron`;
    if (yards < 170) return `For ${yards} yards, try using a 5 iron`;
    if (yards < 200) return `For ${yards} yards, try using a 4 iron`;
    return `For ${yards} yards, try using a 3 wood`;
  }

  private determineShotType(distanceYards: number): string {
    if (distanceYards < 50) return 'short-game';
    if (distanceYards < 100) return 'wedge-shot';
    if (distanceYards < 150) return 'approach-shot';
    if (distanceYards < 200) return 'mid-iron';
    if (distanceYards < 250) return 'long-iron';
    return 'driver-shot';
  }

  private buildWeatherDescription(conditions: {
    windSpeedMph?: number;
    windDirection?: string;
    temperature?: number;
    courseCondition?: string;
  }): string {
    const parts: string[] = [];
    
    if (conditions.temperature) {
      parts.push(`${conditions.temperature}¬∞F`);
    }
    
    if (conditions.windSpeedMph && conditions.windDirection) {
      parts.push(`${conditions.windSpeedMph}mph ${conditions.windDirection} wind`);
    }
    
    if (conditions.courseCondition) {
      parts.push(conditions.courseCondition);
    }
    
    return parts.join(', ') || 'Good conditions';
  }

  /**
   * Build cache key for response caching
   */
  private buildCacheKey(scenario: CaddieScenario, context: CaddieContext): string {
    const distance = context.golfContext?.targetDistanceYards || 150;
    // Round distance to nearest 10 for better cache hits
    const roundedDistance = Math.round(distance / 10) * 10;
    return `${scenario}-${roundedDistance}`;
  }

  /**
   * Get cached response if available and not expired
   */
  private getCachedResponse(cacheKey: string): string | null {
    const cached = this.responseCache.get(cacheKey);
    if (cached) {
      return cached;
    }
    return null;
  }

  /**
   * Cache response for future use
   */
  private setCachedResponse(cacheKey: string, response: string): void {
    this.responseCache.set(cacheKey, response);
    // Clear cache after timeout
    setTimeout(() => {
      this.responseCache.delete(cacheKey);
    }, this.cacheTimeout);
  }
}

// Export singleton instance
export const dynamicCaddieService = new DynamicCaddieService();

// Export factory function for dependency injection
export const getDynamicCaddieService = (): DynamicCaddieService => {
  return dynamicCaddieService;
};

// Helper function to check if service is available
export const isDynamicCaddieServiceAvailable = (): boolean => {
  try {
    return getDynamicCaddieService() != null;
  } catch (error) {
    console.error('Dynamic Caddie service is not available:', error);
    return false;
  }
};

// Export the service as default
export default dynamicCaddieService;