import { RealtimeAudioService } from './RealtimeAudioService';
import { OPENAI_CONFIG } from '../config/openai';
import { CaddieContext, CaddieScenario, DynamicCaddieHelper } from './TextToSpeechService';
import TokenStorage from './tokenStorage';
import { SkillLevel } from '../types';
import { store } from '../store';
import { selectUser } from '../store/slices/authSlice';
import { selectActiveRound } from '../store/slices/roundSlice';
import { selectUserSkillContext, selectCurrentShotType } from '../store/slices/aiCaddieSlice';
import { apiService } from './ApiService';

/**
 * Request queue item for managing sequential API calls
 */
interface QueuedRequest {
  id: string;
  scenario: CaddieScenario;
  context: CaddieContext;
  userId: number;
  roundId: number;
  userInput?: string;
  priority: number;
  timestamp: number;
  skillLevel?: SkillLevel;
  shotTypeContext?: any;
}

/**
 * Enhanced caddie context with backend integration
 */
interface EnhancedCaddieContext extends CaddieContext {
  userSkillLevel?: SkillLevel;
  userHandicap?: number;
  shotAnalysis?: {
    shotType: string;
    confidence: number;
    distance?: number;
    clubRecommendation?: string;
  };
  backendContext?: {
    sessionId?: string;
    analysisId?: string;
    greetingMessage?: string;
  };
}

/**
 * Dynamic AI-powered caddie service that replaces hardcoded responses
 * with contextual, personalized golf advice generated by OpenAI real-time audio API
 * Provides immediate, contextual voice responses for shot placement scenarios
 */
export class DynamicCaddieService implements DynamicCaddieHelper {
  private realtimeAudioService: RealtimeAudioService | null = null;
  private isConnected: boolean = false;
  private currentRoundId: number | null = null;
  
  // Request queuing system to prevent simultaneous API calls
  private requestQueue: QueuedRequest[] = [];
  private isProcessingQueue: boolean = false;
  private activeResponseId: string | null = null;
  
  // Response caching for cost efficiency
  private responseCache: Map<string, string> = new Map();
  private cacheTimeout = 300000; // 5 minutes
  
  // Backend API integration
  public backendSessionId: string | null = null;
  
  /**
   * Initialize connection to OpenAI real-time audio service
   */
  private async initializeRealtimeAudio(roundId: number): Promise<void> {
    if (this.realtimeAudioService && this.isConnected && this.currentRoundId === roundId) {
      return; // Already connected to the same round
    }

    try {
      console.log('üéØ DynamicCaddieService: Initializing OpenAI real-time audio connection');
      
      // Concise golf caddie instructions for helpful, brief responses
      const golfInstructions = `Brief helpful golf caddie. Keep responses under 10 words.`;

      this.realtimeAudioService = new RealtimeAudioService({
        model: OPENAI_CONFIG.model,
        voice: OPENAI_CONFIG.voice,
        instructions: golfInstructions,
        temperature: OPENAI_CONFIG.temperature,
        enableVAD: true,
        vadThreshold: 0.5
      });

      // Get auth token and connect
      const authToken = await TokenStorage.getAccessToken();
      if (!authToken) {
        throw new Error('No authentication token available');
      }

      await this.realtimeAudioService.connect(roundId, authToken);
      this.isConnected = true;
      this.currentRoundId = roundId;
      
      // Set up response completion listener for queue management
      this.realtimeAudioService.on('responseCompleted', (response: any) => {
        console.log('üèÅ DynamicCaddieService: Response completed, processing next in queue');
        this.activeResponseId = null;
        this.isProcessingQueue = false;
        // Use setTimeout to ensure proper async execution
        setTimeout(() => this.processNextQueueItem(), 100);
      });
      
      console.log('‚úÖ DynamicCaddieService: Connected to OpenAI real-time audio');
    } catch (error) {
      console.error('‚ùå DynamicCaddieService: Failed to initialize real-time audio:', error);
      throw error;
    }
  }

  /**
   * Generate and speak dynamic caddie response for specific golf scenarios
   * Enhanced with backend AI integration and skill-level context
   */
  async generateResponse(
    scenario: CaddieScenario,
    context: CaddieContext,
    userId: number,
    roundId: number,
    userInput?: string,
    priority: number = 5
  ): Promise<void> {
    console.log(`üéØ DynamicCaddieService: Queuing enhanced response for scenario: ${scenario}`);

    // Get current user context from Redux store
    const state = store.getState();
    const user = selectUser(state);
    const activeRound = selectActiveRound(state);
    const userSkillContext = selectUserSkillContext(state);
    const currentShotType = selectCurrentShotType(state);
    
    // Enhance context with skill level and shot type
    const enhancedContext = this.buildEnhancedContext(context, userSkillContext, currentShotType);
    
    // Check cache first for cost efficiency (with skill level)
    const cacheKey = this.buildCacheKey(scenario, enhancedContext);
    const cachedResponse = this.getCachedResponse(cacheKey);
    if (cachedResponse) {
      console.log(`üí∞ DynamicCaddieService: Using cached response for ${scenario}`);
      const fallbackMessage = this.getFallbackMessage(scenario, enhancedContext);
      return;
    }

    // Add request to queue with enhanced context
    const queuedRequest: QueuedRequest = {
      id: `${scenario}-${Date.now()}-${Math.random().toString(36).substr(2, 9)}`,
      scenario,
      context: enhancedContext,
      userId,
      roundId,
      userInput,
      priority,
      timestamp: Date.now(),
      skillLevel: userSkillContext?.skillLevel,
      shotTypeContext: currentShotType
    };

    this.addToQueue(queuedRequest);
    
    // Start processing queue if not already processing
    if (!this.isProcessingQueue) {
      this.processNextQueueItem();
    }
  }

  /**
   * Add request to queue, sorted by priority (higher priority first)
   */
  private addToQueue(request: QueuedRequest): void {
    this.requestQueue.push(request);
    
    // Sort by priority (higher priority first), then by timestamp (older first)
    this.requestQueue.sort((a, b) => {
      if (a.priority !== b.priority) {
        return b.priority - a.priority; // Higher priority first
      }
      return a.timestamp - b.timestamp; // Older requests first for same priority
    });

    console.log(`üìã DynamicCaddieService: Request queued. Queue length: ${this.requestQueue.length}`);
  }

  /**
   * Process next item in the queue
   */
  private async processNextQueueItem(): Promise<void> {
    console.log(`üîÑ DynamicCaddieService: Attempting to process next queue item. Processing: ${this.isProcessingQueue}, Queue length: ${this.requestQueue.length}, Active: ${!!this.activeResponseId}`);
    
    if (this.isProcessingQueue) {
      console.log('‚ö†Ô∏è DynamicCaddieService: Already processing queue, skipping');
      return;
    }
    
    if (this.requestQueue.length === 0) {
      console.log('üìã DynamicCaddieService: Queue is empty');
      return;
    }
    
    if (this.activeResponseId) {
      console.log('‚ö†Ô∏è DynamicCaddieService: Active response in progress, skipping');
      return;
    }

    this.isProcessingQueue = true;
    const request = this.requestQueue.shift();
    
    if (!request) {
      this.isProcessingQueue = false;
      console.log('‚ùå DynamicCaddieService: No request found after shifting queue');
      return;
    }

    try {
      console.log(`üîÑ DynamicCaddieService: Processing queued request: ${request.scenario} (ID: ${request.id})`);
      this.activeResponseId = request.id;
      
      await this.executeQueuedRequest(request);
      
    } catch (error: any) {
      console.error(`‚ùå DynamicCaddieService: Error processing queued request ${request.id}:`, error);
      
      // Clear active response and continue with next item
      this.activeResponseId = null;
      this.isProcessingQueue = false;
      
      // Process next item after short delay
      setTimeout(() => this.processNextQueueItem(), 500);
    }
  }

  /**
   * Execute a queued request with enhanced backend integration
   */
  private async executeQueuedRequest(request: QueuedRequest): Promise<void> {
    try {
      console.log(`üéØ DynamicCaddieService: Executing enhanced response for scenario: ${request.scenario}`);

      // Try backend AI integration first for enhanced context
      let backendEnhancedMessage: string | null = null;
      if (this.shouldUseBackendIntegration(request.scenario)) {
        backendEnhancedMessage = await this.getBackendEnhancedMessage(request);
      }

      // Initialize or ensure real-time audio connection
      await this.initializeRealtimeAudio(request.roundId);

      if (!this.realtimeAudioService || !this.isConnected) {
        throw new Error('Real-time audio service not available');
      }

      // Update contextual instructions with skill level awareness
      await this.updateContextualInstructions(request.scenario, request.context, request.skillLevel);

      // Use backend-enhanced message or build contextual message
      const contextualMessage = backendEnhancedMessage || 
        this.buildContextualMessage(request.scenario, request.context, request.userInput);
      
      console.log(`üé§ DynamicCaddieService: Sending context to OpenAI: "${contextualMessage}"`);
      
      // Send message to OpenAI real-time audio for immediate voice response
      await this.realtimeAudioService.sendTextMessage(contextualMessage);
      
      console.log('‚úÖ DynamicCaddieService: Enhanced message sent to OpenAI real-time audio');

      // Add timeout fallback in case response completion event isn't fired
      setTimeout(() => {
        if (this.activeResponseId === request.id && this.isProcessingQueue) {
          console.warn('‚ö†Ô∏è DynamicCaddieService: Response timeout, forcing queue continuation');
          this.activeResponseId = null;
          this.isProcessingQueue = false;
          this.processNextQueueItem();
        }
      }, 15000); // 15 second timeout

    } catch (error: any) {
      console.error(`‚ùå DynamicCaddieService: Error executing request for ${request.scenario}:`, error);
      
      // Fallback to static message if OpenAI fails
      const fallbackMessage = this.getFallbackMessage(request.scenario, request.context);
      console.warn(`üîÑ DynamicCaddieService: Using fallback message: "${fallbackMessage}"`);
      
      // Clear processing state and continue with queue
      this.activeResponseId = null;
      this.isProcessingQueue = false;
      setTimeout(() => this.processNextQueueItem(), 500);
    }
  }

  /**
   * Generate response with enhanced context building
   */
  async generateResponseWithEnhancedContext(
    scenario: CaddieScenario,
    baseContext: Partial<CaddieContext>,
    userId: number,
    roundId: number,
    enhancementOptions?: {
      includeWeather?: boolean;
      includePlayerStats?: boolean;
      includeConversationHistory?: boolean;
      playerSkillLevel?: SkillLevel;
      communicationStyle?: string;
    },
    userInput?: string,
    priority: number = 5
  ): Promise<void> {
    try {
      // Enhance context with additional information
      const enhancedContext: CaddieContext = {
        ...baseContext,
        player: {
          ...baseContext.player,
          skillLevel: enhancementOptions?.playerSkillLevel ?? baseContext.player?.skillLevel ?? SkillLevel.Intermediate,
          communicationStyle: (enhancementOptions?.communicationStyle ?? baseContext.player?.communicationStyle ?? 'encouraging') as 'encouraging' | 'technical' | 'balanced' | 'casual' | 'professional',
        },
        metadata: {
          ...baseContext.metadata,
          enhancementOptions,
          requestTimestamp: new Date().toISOString(),
        }
      };

      // Generate response with enhanced context
      await this.generateResponse(scenario, enhancedContext, userId, roundId, userInput, priority);

    } catch (error) {
      console.error('Error generating enhanced caddie response:', error);
      
      // Fall back to basic response generation
      await this.generateResponse(scenario, baseContext, userId, roundId, userInput, priority);
    }
  }

  /**
   * Generate response for shot placement scenarios with automatic context building
   */
  async generateShotPlacementResponse(
    scenario: Extract<CaddieScenario, 'ShotPlacementWelcome' | 'ShotPlacementConfirmation' | 'ShotTrackingActivation'>,
    userId: number,
    roundId: number,
    shotContext: {
      currentHole?: number;
      targetDistanceYards?: number;
      recommendedClub?: string;
      currentLocation?: {
        latitude: number;
        longitude: number;
        accuracy?: number;
      };
      shotHistory?: Array<{
        shotNumber: number;
        club?: string;
        distanceYards: number;
        accuracy?: string;
        timestamp: number;
      }>;
    },
    priority: number = 8
  ): Promise<void> {
    const context: CaddieContext = {
      location: shotContext.currentLocation ? {
        currentHole: shotContext.currentHole,
        latitude: shotContext.currentLocation.latitude,
        longitude: shotContext.currentLocation.longitude,
        accuracyMeters: shotContext.currentLocation.accuracy ?? 10,
        withinCourseBoundaries: true,
        timestamp: new Date().toISOString(),
      } : undefined,
      golfContext: {
        currentHole: shotContext.currentHole,
        targetDistanceYards: shotContext.targetDistanceYards,
        recommendedClub: shotContext.recommendedClub,
        shotType: this.determineShotType(shotContext.targetDistanceYards ?? 150),
        shotPlacementActive: true,
        shotHistory: shotContext.shotHistory,
      },
      player: {
        skillLevel: SkillLevel.Intermediate, // Could be enhanced with user preferences
        communicationStyle: 'encouraging',
      }
    };

    await this.generateResponse(scenario, context, userId, roundId, undefined, priority);
  }

  /**
   * Generate skill-aware club recommendation with backend integration
   */
  async generateClubRecommendation(
    userId: number,
    roundId: number,
    distanceYards: number,
    conditions?: {
      windSpeedMph?: number;
      windDirection?: string;
      temperature?: number;
      courseCondition?: string;
    },
    currentHole?: number,
    playerClubDistances?: Record<string, number>,
    priority: number = 8
  ): Promise<void> {
    // Get current skill level from Redux store
    const state = store.getState();
    const userSkillContext = selectUserSkillContext(state);
    const skillLevel = userSkillContext?.skillLevel || SkillLevel.Intermediate;
    
    const context: CaddieContext = {
      golfContext: {
        currentHole,
        targetDistanceYards: distanceYards,
        shotType: this.determineShotType(distanceYards),
      },
      player: {
        skillLevel,
        communicationStyle: this.getCommunicationStyleForSkillLevel(userSkillContext?.skillLevel) as 'encouraging' | 'technical' | 'balanced' | 'casual' | 'professional',
        clubDistances: playerClubDistances,
      },
      conditions: conditions ? {
        windSpeedMph: conditions.windSpeedMph,
        windDirection: conditions.windDirection,
        temperatureFahrenheit: conditions.temperature,
        courseCondition: conditions.courseCondition,
        weatherDescription: this.buildWeatherDescription(conditions),
      } : undefined,
    };

    await this.generateResponse('ClubRecommendation', context, userId, roundId, undefined, priority);
  }

  /**
   * Note: Realtime audio functionality moved to VoiceChatModalV2 component
   * This service now focuses on contextual API responses with TTS
   */

  /**
   * Cleanup and disconnect from real-time audio service
   */
  async cleanup(): Promise<void> {
    // Clear request queue and processing state
    this.requestQueue = [];
    this.isProcessingQueue = false;
    this.activeResponseId = null;
    
    if (this.realtimeAudioService && this.isConnected) {
      try {
        await this.realtimeAudioService.disconnect();
        console.log('üßπ DynamicCaddieService: Disconnected from real-time audio service');
      } catch (error) {
        console.error('‚ùå DynamicCaddieService: Error during cleanup:', error);
      }
    }
    
    this.realtimeAudioService = null;
    this.isConnected = false;
    this.currentRoundId = null;
  }

  /**
   * Build minimal contextual message for 2 core shot placement scenarios only
   */
  private buildContextualMessage(scenario: CaddieScenario, context: CaddieContext, userInput?: string): string {
    const distance = context.golfContext?.targetDistanceYards || 150;

    // Only handle the 2 essential shot placement cases
    switch (scenario) {
      case 'ShotPlacementWelcome':
        return 'Shot placement activated';
      case 'ClubRecommendation':
        return `${distance} yards club recommendation`;
      default:
        return 'Golf help';
    }
  }

  /**
   * Update contextual instructions with skill level awareness
   */
  private async updateContextualInstructions(
    scenario: CaddieScenario, 
    context: CaddieContext, 
    skillLevel?: SkillLevel
  ): Promise<void> {
    if (!this.realtimeAudioService) return;

    // Build skill-appropriate instructions
    let instruction = this.buildSkillBasedInstruction(scenario, skillLevel);
    
    const skillLevelName = skillLevel ? SkillLevel[skillLevel] : 'Intermediate';
    console.log(`üéØ DynamicCaddieService: Setting skill-based instruction for ${skillLevelName}: "${instruction}"`);

    // Update with skill-aware scenario instructions
    this.realtimeAudioService.updateConfig({
      instructions: instruction,
      voice: 'ash',
      temperature: 0.6 // Minimum allowed for real-time API
    });
  }

  /**
   * Get skill-appropriate fallback message for scenarios when API is unavailable
   */
  private getFallbackMessage(scenario: CaddieScenario, context: EnhancedCaddieContext): string {
    const skillLevel = context.userSkillLevel || SkillLevel.Intermediate;
    
    switch (scenario) {
      case 'ShotPlacementWelcome':
        return this.getSkillBasedWelcomeMessage(skillLevel);
      
      case 'ClubRecommendation':
        const distance = context.golfContext?.targetDistanceYards ?? 150;
        return this.getSkillBasedClubRecommendation(distance, skillLevel);
      
      case 'GeneralAssistance':
        return this.getSkillBasedGeneralAdvice(skillLevel);
      
      case 'ErrorHandling':
        return this.getSkillBasedErrorMessage(skillLevel);
      
      default:
        return this.getSkillBasedGeneralAdvice(skillLevel);
    }
  }

  /**
   * Get skill-based club recommendation with appropriate complexity
   */
  private getSkillBasedClubRecommendation(yards: number, skillLevel: SkillLevel): string {
    let club = this.getClubForDistance(yards);
    
    switch (skillLevel) {
      case SkillLevel.Beginner:
        return `Try a ${club} for ${yards} yards. Focus on smooth contact.`;
      case SkillLevel.Intermediate:
        return `For ${yards} yards, use a ${club}. Trust your swing.`;
      case SkillLevel.Advanced:
        return `${yards} yards calls for a ${club}. Consider wind and pin position.`;
      case SkillLevel.Professional:
        return `${club} for ${yards}y. Factor in conditions and spin rate.`;
      default:
        return `For ${yards} yards, try a ${club}.`;
    }
  }
  
  private getClubForDistance(yards: number): string {
    if (yards < 80) return 'wedge';
    if (yards < 120) return '9 iron';
    if (yards < 150) return '7 iron';
    if (yards < 170) return '5 iron';
    if (yards < 200) return '4 iron';
    return '3 wood';
  }
  
  private getSkillBasedWelcomeMessage(skillLevel: SkillLevel): string {
    switch (skillLevel) {
      case SkillLevel.Beginner:
        return 'Welcome! Select where you want to hit the ball.';
      case SkillLevel.Intermediate:
        return 'Ready to place your shot. Tap your target location.';
      case SkillLevel.Advanced:
        return 'Shot placement active. Choose your strategic target.';
      case SkillLevel.Professional:
        return 'Shot placement engaged. Select optimal target position.';
      default:
        return 'Select your shot location on the map.';
    }
  }
  
  private getSkillBasedGeneralAdvice(skillLevel: SkillLevel): string {
    switch (skillLevel) {
      case SkillLevel.Beginner:
        return "I'm here to help you learn golf basics!";
      case SkillLevel.Intermediate:
        return "Ready to help improve your game!";
      case SkillLevel.Advanced:
        return "Let's work on strategy and technique!";
      case SkillLevel.Professional:
        return "Ready to analyze advanced golf scenarios!";
      default:
        return "How can I help with your golf game?";
    }
  }
  
  private getSkillBasedErrorMessage(skillLevel: SkillLevel): string {
    switch (skillLevel) {
      case SkillLevel.Beginner:
        return "No worries! Let's keep practicing together.";
      case SkillLevel.Intermediate:
        return "All good! Let's get back to your game.";
      case SkillLevel.Advanced:
        return "No problem! Ready to continue with strategic advice.";
      case SkillLevel.Professional:
        return "System restored. Ready for advanced analysis.";
      default:
        return "No worries! Let's continue with your round.";
    }
  }

  private determineShotType(distanceYards: number): string {
    if (distanceYards < 50) return 'short-game';
    if (distanceYards < 100) return 'wedge-shot';
    if (distanceYards < 150) return 'approach-shot';
    if (distanceYards < 200) return 'mid-iron';
    if (distanceYards < 250) return 'long-iron';
    return 'driver-shot';
  }

  private buildWeatherDescription(conditions: {
    windSpeedMph?: number;
    windDirection?: string;
    temperature?: number;
    courseCondition?: string;
  }): string {
    const parts: string[] = [];
    
    if (conditions.temperature) {
      parts.push(`${conditions.temperature}¬∞F`);
    }
    
    if (conditions.windSpeedMph && conditions.windDirection) {
      parts.push(`${conditions.windSpeedMph}mph ${conditions.windDirection} wind`);
    }
    
    if (conditions.courseCondition) {
      parts.push(conditions.courseCondition);
    }
    
    return parts.join(', ') || 'Good conditions';
  }
  
  /**
   * Get appropriate communication style based on skill level
   */
  private getCommunicationStyleForSkillLevel(skillLevel?: number): string {
    switch (skillLevel) {
      case SkillLevel.Beginner:
        return 'encouraging';
      case SkillLevel.Intermediate:
        return 'balanced';
      case SkillLevel.Advanced:
        return 'technical';
      case SkillLevel.Professional:
        return 'professional';
      default:
        return 'encouraging';
    }
  }

  /**
   * Generate general golf advice outside of active rounds
   */
  async generateGeneralAdvice(
    userId: number,
    userInput?: string,
    priority: number = 5
  ): Promise<void> {
    console.log('üéØ DynamicCaddieService: Generating general golf advice');
    
    // Get current skill level from Redux store
    const state = store.getState();
    const userSkillContext = selectUserSkillContext(state);
    const activeRound = selectActiveRound(state);
    
    const context: CaddieContext = {
      player: {
        skillLevel: userSkillContext?.skillLevel || SkillLevel.Intermediate,
        communicationStyle: this.getCommunicationStyleForSkillLevel(userSkillContext?.skillLevel) as 'encouraging' | 'technical' | 'balanced' | 'casual' | 'professional',
      },
      metadata: {
        isGeneralAdvice: true,
        hasActiveRound: !!activeRound,
      }
    };

    await this.generateResponse('GeneralAssistance', context, userId, activeRound?.id || 0, userInput, priority);
  }

  /**
   * Build cache key for response caching with skill level
   */
  private buildCacheKey(scenario: CaddieScenario, context: EnhancedCaddieContext): string {
    const distance = context.golfContext?.targetDistanceYards || 150;
    const skillLevel = context.userSkillLevel || SkillLevel.Intermediate;
    // Round distance to nearest 10 for better cache hits
    const roundedDistance = Math.round(distance / 10) * 10;
    return `${scenario}-${skillLevel}-${roundedDistance}`;
  }

  /**
   * Get cached response if available and not expired
   */
  private getCachedResponse(cacheKey: string): string | null {
    const cached = this.responseCache.get(cacheKey);
    if (cached) {
      return cached;
    }
    return null;
  }

  /**
   * Cache response for future use
   */
  private setCachedResponse(cacheKey: string, response: string): void {
    this.responseCache.set(cacheKey, response);
    // Clear cache after timeout
    setTimeout(() => {
      this.responseCache.delete(cacheKey);
    }, this.cacheTimeout);
  }

  /**
   * Build enhanced context with skill level and shot type information
   */
  private buildEnhancedContext(
    baseContext: CaddieContext, 
    userSkillContext: any, 
    currentShotType: any
  ): EnhancedCaddieContext {
    return {
      ...baseContext,
      userSkillLevel: userSkillContext?.skillLevel,
      userHandicap: userSkillContext?.handicap,
      shotAnalysis: currentShotType ? {
        shotType: currentShotType.type,
        confidence: currentShotType.confidence,
        distance: currentShotType.distance,
      } : undefined,
      backendContext: {
        sessionId: this.backendSessionId || undefined
      }
    };
  }

  /**
   * Build skill-appropriate instruction for OpenAI
   */
  private buildSkillBasedInstruction(scenario: CaddieScenario, skillLevel?: SkillLevel): string {
    const baseInstruction = 'Brief helpful golf caddie. Under 10 words.';
    
    // Adjust instruction complexity based on skill level
    const skillSuffix = this.getSkillBasedSuffix(skillLevel);
    
    switch (scenario) {
      case 'ShotPlacementWelcome':
        return `Welcome to shot placement. ${skillSuffix}`;
      case 'ClubRecommendation':
        return `Recommend club for distance. ${skillSuffix}`;
      case 'GeneralAssistance':
        return `Provide golf advice. ${skillSuffix}`;
      case 'ErrorHandling':
        return `Reassure and help continue. ${skillSuffix}`;
      default:
        return `${baseInstruction} ${skillSuffix}`;
    }
  }

  /**
   * Get skill-appropriate instruction suffix
   */
  private getSkillBasedSuffix(skillLevel?: SkillLevel): string {
    switch (skillLevel) {
      case SkillLevel.Beginner:
        return 'Use simple terms and encouraging tone.';
      case SkillLevel.Intermediate:
        return 'Provide standard golf advice.';
      case SkillLevel.Advanced:
        return 'Include technical details and strategy.';
      case SkillLevel.Professional:
        return 'Advanced technical analysis and precise recommendations.';
      default:
        return 'Provide standard golf advice.';
    }
  }

  /**
   * Check if scenario should use backend integration for enhanced context
   */
  private shouldUseBackendIntegration(scenario: CaddieScenario): boolean {
    return ['ClubRecommendation', 'ShotPlacementWelcome', 'GeneralAssistance'].includes(scenario);
  }

  /**
   * Get backend-enhanced message with skill level and shot analysis
   */
  private async getBackendEnhancedMessage(request: QueuedRequest): Promise<string | null> {
    try {
      // For club recommendations, get backend analysis
      if (request.scenario === 'ClubRecommendation' && request.context.golfContext?.targetDistanceYards) {
        const response = await apiService.get(
          `ai-caddie/club-recommendation/${request.userId}?distanceYards=${request.context.golfContext.targetDistanceYards}`,
          { retryAttempts: 1, timeout: 5000 }
        );

        if (response.success && response.data) {
          return `${response.data.primaryClub} for ${request.context.golfContext.targetDistanceYards} yards. ${response.data.advice || ''}`;
        }
      }
      
      // For general assistance, try to get contextual greeting
      if (request.scenario === 'GeneralAssistance' || request.scenario === 'ShotPlacementWelcome') {
        if (!request.roundId) return null;

        const response = await apiService.get(
          `ai-caddie/greeting/${request.userId}/${request.roundId}`,
          { retryAttempts: 1, timeout: 5000 }
        );

        if (response.success && response.data) {
          return response.data;
        }
      }

      return null;
    } catch (error) {
      console.warn('üîÑ DynamicCaddieService: Backend integration failed, using fallback:', error);
      return null;
    }
  }
}

// Export singleton instance
export const dynamicCaddieService = new DynamicCaddieService();

// Export factory function for dependency injection
export const getDynamicCaddieService = (): DynamicCaddieService => {
  return dynamicCaddieService;
};

// Helper function to check if service is available
export const isDynamicCaddieServiceAvailable = (): boolean => {
  try {
    return getDynamicCaddieService() != null;
  } catch (error) {
    console.error('Dynamic Caddie service is not available:', error);
    return false;
  }
};

/**
 * Initialize enhanced AI caddie session with backend integration
 */
export const initializeEnhancedAICaddieSession = async (
  userId: number,
  roundId?: number,
  currentHole?: number
): Promise<{ sessionId: string; success: boolean }> => {
  try {
    const response = await apiService.post('ai-caddie/voice-session', {
      userId,
      roundId,
      currentHole
    });

    if (response.success && response.data) {
      dynamicCaddieService.backendSessionId = response.data.sessionId;
      console.log('‚úÖ Enhanced AI Caddie session initialized:', response.data.sessionId);
      return { sessionId: response.data.sessionId, success: true };
    } else {
      throw new Error(response.message || 'Backend initialization failed');
    }
  } catch (error) {
    console.error('‚ùå Failed to initialize enhanced AI caddie session:', error);
    return { sessionId: '', success: false };
  }
};

// Export the service as default
export default dynamicCaddieService;